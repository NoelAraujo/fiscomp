[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FisComp",
    "section": "",
    "text": "Física Computacional, ou FisComp para os íntimos, é uma disciplina comum em cursos universitários de Física. Isso se faz necessário, pois, de uma maneira ou outra, em pleno século 21 não é possível fazer física sem o auxílio do computador, e essa disciplina visa ensinar conceito de Métodos Numéricos aplicados à Física.\nEntretanto, do ponto de vista do autor desse livro, os livros a respeito desse assunto são focados excessivamente em derivações dos métodos numéricos, e deixam a contextualização muito superficial da física envolvida. Isso é frustrante, pois o estudante não é exposto a diferentes cenários, gerando a impressão que todos os algoritmos que aprendeu, só servem para passar na prova.\nComo alternativa ao status quo, esse texto é criado do zero, com a finalidade de ensinar Física Computacional com mais ênfase na Física. Vários Projetos Temáticos discutirão, em muitos detalhes, como obter física utilizando diferentes técnicas computacionais.\nSe tudo der certo, espero que esse texto impacte sua vida, servindo como um exemplo, uma base, uma fonte de inspiração, para que você produzá conteúdos melhores do que aqui apresentados.\nDesejo agradecer eternamente aos meus amigos pela paciência de revisar as primeiras versões desse projetos.\n\nEssa página foi gerada com https://quarto.org/docs/books."
  },
  {
    "objectID": "projetos.html",
    "href": "projetos.html",
    "title": "Projetos",
    "section": "",
    "text": "Todos os projetos são:\n\npensados para alunos que já cursaram Cálculo 1, Algebra Linear, Física 1, e Introdução a Programação;\nrealizados com linguagem Julia, pois ela possui alta performance, similar ao C e Fortran, além de recursos modernos que facilitarão sua vida de programador;\natualizados assim que recebe qualquer feedback dos leitores. Por favor, indique todas as questões que as instruções não estão claras, ou simplismente se o projeto ficou complicado de mais. Sua opinião honesta faz a diferença."
  },
  {
    "objectID": "Projeto1/projeto1.html",
    "href": "Projeto1/projeto1.html",
    "title": "1  Prólogo",
    "section": "",
    "text": "Objetivo Geral: Quebrar o gelo com a linguagem Julia.\nObjetivo Especifico: Resolver vários exercícios de pequena complexidade, para mostrar funcionalidades da linguagem que serão recorrente durante o curso\nConteúdo: Entrada e Saída; Álgebra Linear; Estruturas de repetição; Erros numéricos; Multiple-Dispatch\nSe você já sabe Julia, ou consegue resolver os exercícios sem dificuldades, simplesmente pule esse projeto."
  },
  {
    "objectID": "Projeto1/projeto1.html#vetores-e-matrizes",
    "href": "Projeto1/projeto1.html#vetores-e-matrizes",
    "title": "1  Prólogo",
    "section": "1.1 Vetores e Matrizes",
    "text": "1.1 Vetores e Matrizes\nÉ muito difícil você fazer Física sem usar vetores ou matrizes, por isso você precisa dominar operações básicas de Algebra Linear.\n\nDados 3 vetores \\(\\vec{a} = (1,-1,1)\\), \\(\\vec{b} = (-3,1,5)\\) e \\(\\vec{c} = (4,-7,3)\\) :\n\nCalcule a norma (valor absoluto Euclidiano) de cada vetor.\nCalcule o produto escalar e vetorial entre todas as combinações de \\(\\vec{a},\\vec{b}\\) e \\(\\vec{c}\\).\nCalcule o ângulo entre os vetores \\(\\vec{ab}\\) e \\(\\vec{ac}\\).\nCrie a matriz \\(A = [\\vec{a}\\; \\vec{b}\\; \\vec{c}]\\) e calcule seu determinante."
  },
  {
    "objectID": "Projeto1/projeto1.html#leitura-e-escrita",
    "href": "Projeto1/projeto1.html#leitura-e-escrita",
    "title": "1  Prólogo",
    "section": "1.2 Leitura e Escrita",
    "text": "1.2 Leitura e Escrita\nOutra tarefa recorrente em programação é leitura de dados em arquivo para posterior análise.\n\nVoltaremos aos tempos de ensino médio, e vamos calcular tempo de queda livre \\(t_q = \\sqrt{2h/g}\\), porém não apenas na Terra.\n\nPesquise o valor da aceleração da gravidade, \\(g\\), em diferentes planetas do sistema solar. Salve seus resultados em um arquivo .txt, cuja primeira coluna é o nome do planeta, e na segunda o valor de \\(g\\). Separe os dados com uma vírgula.\nUse o pacote DelimitedFiles.jl para ler os dados em uma matriz.\nPara cada planeta, calcule quanto tempo um objeto demora para atingir o solo, dado que a altura inicial é \\(h=120 m\\).\nPor meio de interpolação de texto, exiba seus resultados como: \"[planeta]: tempo de queda é [tempo] segundos\".\nUse funções padrões de Julia, e descubra qual o planeta que demora mais e menos tempo para a queda acontecer."
  },
  {
    "objectID": "Projeto1/projeto1.html#estrutura-de-repetição",
    "href": "Projeto1/projeto1.html#estrutura-de-repetição",
    "title": "1  Prólogo",
    "section": "1.3 Estrutura de Repetição",
    "text": "1.3 Estrutura de Repetição\n\nIgnorando um gama gigantesca de fatores, vamos assumir, o cenário irrealístico, de que a temperatura anual de uma cidade na região Sudeste do Brasil é descrito por uma função cosseno, cuja miníma anual é 5°, e máxima anual é 35°, acontecendo no primeiro dia do Verão, dia 21 de dezembro (que corresponde ao 355° dia do ano).\n\nCrie uma função que simule o comportamento de temperatura anual.\nVamos trabalhar as datas como índices. Crie um vetor com todos os números de 1 até 365.\nCalcule a temperatura anual usando for, map e o operador broadcasting, representado por um ponto \".\"\nCrie uma figura com seu resultado, usando o pacote Plots.jl.\n\n\n\n\n\n\n\n\nDica\n\n\n\nProcure por Trig word problem: modeling annual temperature na Internet."
  },
  {
    "objectID": "Projeto1/projeto1.html#trigonometria",
    "href": "Projeto1/projeto1.html#trigonometria",
    "title": "1  Prólogo",
    "section": "1.4 Trigonometria",
    "text": "1.4 Trigonometria\nComputadores são máquinas incríveis para fazer contas, mas ainda sim possuem limites. Vamos testar um deles com o cálculo da função seno.\n\nCrie um programa para estimar o valor de sen(x) através de sua expansão de Taylor truncada em \\(N\\) elementos: \\[\n    sin(x) = \\sum_{n=0}^{N} (-1)^n \\frac{x^{2n+1}}{(2n+1)!}\n\\]\n\n\nEscolha um valor de \\(x\\) e calcule a série para \\(N\\) diferentes. Quanto maior \\(N\\), melhor será seus resultado, e nós desejamos verificar isso exibindo os erro absoluto em um plot de escala logarítmica. Use a biblioteca Plots.jl para isso.\nPara quais valores de \\(N\\) você não consegue mais realizar a somatória ? Por quê?\n\n\n\n\n\n\n\nNota\n\n\n\nerro absoluto = \\(|y_{estimado} - y_{exato}|\\).\nUse a função sin(x) que já vem por padrão em Julia para obter o valor exato."
  },
  {
    "objectID": "Projeto1/projeto1.html#resistores-em-série",
    "href": "Projeto1/projeto1.html#resistores-em-série",
    "title": "1  Prólogo",
    "section": "1.5 Resistores em Série",
    "text": "1.5 Resistores em Série\nSerá inevitável que você fará uso de pacotes prontos. E é comum em Julia a criação de novos tipos de dados - tipos no sentido Int ou Float. Esse recurso permite que você desenvolva códigos mais inteligível e tudo começa com struct. Nesse exercício criaremos um tipo de dado para ajudar a calcular resistências em série de circuitos elétricos.\n\nDefina um struct1 chamado resistor com 2 campos do tipo Number: Resistência, \\(R\\) e Corrente, \\(i\\).\n\n\nInstancie 2 resistores em série, com \\(i = 4A\\), e \\(R_1 = 5\\Omega\\) e \\(R_2 = 20\\Omega\\).\nCrie uma função que receba o tipo de entrada resistor e retorne a tensão \\(U = R\\cdot i\\).\nCrie um novo método que some 2 resistências em série e retorne um novo objeto do tipo resistor."
  },
  {
    "objectID": "Projeto2/projeto2.html",
    "href": "Projeto2/projeto2.html",
    "title": "2  Tratamento de Dados",
    "section": "",
    "text": "Objetivo Geral: Aprender como obter taxas de decaimento.\nObjetivo Especifico: Fazer fits de curvas de decaimento com lei de potência, típico de sistemas de atenuação de energia no espaço. Como a taxa de decaimento é rápida, você precisará ter cuidado adicional para fazer seu fitting.\nConteúdo: Escala Logarítmica; Lei do Inverso do Quadrado da Distância; Despacito; Métodos dos Mínimos Quadrados; Propagação de Erros.\nUma situação que você fará uso de computador para facilitar sua vida no mundo da Física, será para obtenção e tratamentos de dados experimentais. Rotineiramente você precisará criar figuras com os seus resultados, estimar parâmetros relevantes do sistema e ainda escrever relatórios. Como não são todos os estudantes que tem a oportunidade de ter uma aula específica sobre esses assuntos, esse projeto será um guia inicial de como fazer tratamentos de dados."
  },
  {
    "objectID": "Projeto2/projeto2.html#o-experimento",
    "href": "Projeto2/projeto2.html#o-experimento",
    "title": "2  Tratamento de Dados",
    "section": "2.1 O Experimento",
    "text": "2.1 O Experimento\nVocê pode aumentar ou diminuir a altura do som do seu celular com 2 botões. Contudo, seu ouvido não funciona da mesma maneira. Se você é exposto a sons de mesma intensidade, mas frequências diferentes, você terá a impressão que os sons estão em volumes diferentes. Essa sensibilidade diferente para cada frequência depende de pessoa para pessoa, e sua primeira atividade será descobrir os limites dos seus ouvidos.\nVocê irá realizar o experimento proposto em [Staff 2020], para acessar os seus detalhes, clique aqui. A atividade consiste em escutar sons com frequências bem definidas, porém de intensidades diferentes ao longo do tempo. Ao contar a quantidade de tons, você conseguirá calcular os seus limites auditivos.\n\n\n\n\n\n\nAviso\n\n\n\nNão esqueça que seu primeiro passo na atividade não é preencher a tabela, mas sim ajustar a altura do fone de ouvido para que você escute 18 ou 19 batidas em 3500Hz.\nLeia toda a prática antes de começar a realiza-lá.\n\n\n\n\n\n\n\n\nAviso\n\n\n\nNão se preocupe com os resultados no regime de alta frequência. Fones de ouvidos não são feitos para ter alta fidelidade nessa região, logo, você provavelmente não escutará tantas batidas.\nRelaxe, você não está surdo.\n\n\n\n\n\n\n\n\nDica\n\n\n\nEsse experimento é longo e será inevitável a fadiga. Isso é um problema para garantir a qualidade dos seus dados, pois você terá muita atenção para contar as batidas no começo da prática, e não terá a mesma disposição e atenção para contar batidas no final do experimento.\nUma maneira de contornar o cansaço físico é não realizar o experimento de forma linear, escute as frequências em ordem aleatória.\n\n\n\nLeia atentamente a descrição do experimento e preencha uma tabela com a quantidade de batidas que você escutou em cada repetição.\n\nArmazene os seus resultados em uma planilha.\nSalve os dados como um arquivo CSV.\nLeia os dados em Julia com o pacote DelimitedFiles.jl, e com o pacote de vizualização de sua escolha, faça um gráfico semilogx dos seus resultados.\nO tamanho da fonte da figura deve ser comparável ao texto onde ele estará embutido.\n\n\n\n\n\n\n\n\nObservação\n\n\n\n\n\nSalvar arquivos em formato .csv é conveniente apenas quando o conjunto de dados é pequeno, pois você pode acessar os dados com um editor de texto.\nQuando o conjunto de dados é enorme, e você não precisa de uma banco de dados, use arquivos do formato .hdf5."
  },
  {
    "objectID": "Projeto3/projeto3.html",
    "href": "Projeto3/projeto3.html",
    "title": "3  O Sol",
    "section": "",
    "text": "Objetivo Geral: Aprender alguns princípios de cálculo numérico.\nObjetivo Especifico: Calcular o valor de derivadas e integrais com métodos numéricos, usando a física de radiação de corpo negro como pano de fundo. Esse assunto é uma das primeiras vezes no curso de Física no qual é necessário encontrar a solução (a raiz) de uma equação transcendental.\nConteúdo: Radiação de Corpo Negro; Derivada; Ordem de Erro; Método de Newton-Raphson, Método da Secante; Quadratura do Trapézio, Simpson, Bode.\nVocê já assistiu algum filme do Predador? Uma das características mais marcantes do personagem é sua tecnologia de visão noturna. Isso não é pura ficção científica, há décadas que seres humanos também já usam imagens térmicas, e aplicações fora do campo militar existem aos montes, a mais interessante que devo mencionar é a observação de capivaras como na Figura 3.1.\nTudo que possui matéria emite ondas eletromagnéticas em diferentes frequências. Você nesse momento esta emitindo radiação no regime do infra-vermelho, que nosso olhos não conseguem ver, mesmo você estando brilhando. A explicação desse fenômeno é recente na história da humanidade, e em seu curso de Física Moderna, estudará a Radiação de Corpo Negro."
  },
  {
    "objectID": "Projeto3/projeto3.html#radiação-solar",
    "href": "Projeto3/projeto3.html#radiação-solar",
    "title": "3  O Sol",
    "section": "3.1 Radiação Solar",
    "text": "3.1 Radiação Solar\nO melhor exemplo de Corpo Negro que qualquer um pode acessar, é Sol de todo dia1. Ele parece amarelo, mas na verdade é composto de vários comprimentos de onda diferentes, alguns dos quais são bloqueados pela atmosfera (lembra da Camada de Ozônio?), outros chegam na superfície, e fazem a vida prosperar - o pico do espectro solar ser no campo visível humano é provavelmente uma coincidência causada por uma junção de fatores complexos.\n\n\n\nFigura 3.2: Irradiância por comprimento de onda obtido na superfície da Terra, em vermelho, e no topo de atmosfera, em amarelo. A região de máximo de irradiância depende da Temperatura do corpo que emissor. O Sol tem pico na região vísivel, você tem um pico na região infra-vermelha. Fonte: Wikipédia\n\n\nPara estimar o espectro de radiação de qualquer objetivo no universo, usamos a Lei de Planck. Ela será nosso objeto de estudo nesse projeto pois uma equação que facilmente recorremos a ajuda de Cálculo Numérico. As próximas seções são dedicadas a apresentar o mínimo de cálculo numérico.\nNão tenha medo do tamanho do projeto. As tarefas serão fáceis, mas como os conceitos são novos, eu preciso dedicar mais tempo explicando os detalhes."
  },
  {
    "objectID": "Projeto3/projeto3.html#derivada",
    "href": "Projeto3/projeto3.html#derivada",
    "title": "3  O Sol",
    "section": "3.2 Derivada",
    "text": "3.2 Derivada\nEm algum momento durante seu curso de Cálculo 1, você viu a definição de Derivada através do uso de Limite em um ponto \\(t_0\\) é :\n\\[\n    f'(t_0) = \\lim_{\\Delta t \\to 0} \\frac{ f(t_0 + \\Delta t) - f(t_0) }{\\Delta t}.\n\\]\n\n\n\nFigura 3.3: Em principio você consegue estimar derivadas de qualquer função se \\(\\Delta t\\) for muito pequeno.\n\n\nPara ser estritamente correto, o valor de \\(\\Delta t\\) deve ser um infinitesimal. Contudo, fazem alguns séculos que engenheiros e físicos assumem que \\(\\Delta t\\) seja apenas um valor pequeno o suficiente2, permitindo calcular derivadas por força bruta.\nPelo que escrevi até o momento, a derivada em certo posição deveria ser uma expressão simples, apenas calculamos:\n\\[\n    \\frac{ f(t_0 + \\Delta t) - f(t_0) }{\\Delta t}\n\\tag{3.1}\\]\nContudo, aparecem erros de arredondamento ou erros de truncamento e nossas respostas perdem precisão dependendo do valor de \\(\\Delta t\\).\nOs erros de truncamento não são imprevisíveis, em muitos casos sabemos a Ordem de Magnitude, o big oh, \\(\\mathcal{O}(\\Delta t)\\) do nosso problema,por exemplo, para a Equação 3.1, o erro de truncamento é \\(\\mathcal{O}(\\Delta t)\\).\nLivros de Cálculo Numérico ou Análise de Algoritmos trazem uma discussão mais elaborada sobre esse assunto. Aqui, o ponto importante é conhecer o vocabulário de cálculo numérico e seus conceitos.\nA Tabela 3.1 e Tabela 3.2 contêm fórmulas que você fará uso durante esse projeto.\n\n\nTabela 3.1: Derivadas de Primeira Ordem\n\n\n\n\n\n\n\n\nFórmula\nErro\n\n\n\n\nPara Frente de 2 pontos\n\\(f'(t_0)\\) = \\(\\frac{ f(t_0 + \\Delta t) - f(\\Delta t) }{\\Delta t}\\)\n\\(\\mathcal{O}(\\Delta t)\\)\n\n\nPara traz de 2 pontos\n\\(f'(t_0)\\) = \\(\\frac{ f(t_0) - f(t_0 - \\Delta t) }{\\Delta t}\\)\n\\(\\mathcal{O}(\\Delta t)\\)\n\n\nSimétrica de 3 pontos\n\\(f'(t_0)\\) = \\(\\frac{ f(t_0+ \\Delta t) - f(t_0 - \\Delta t) }{2\\Delta t}\\)\n\\(\\mathcal{O}(\\Delta t^2)\\)\n\n\nSimétrica de 5 pontos\n\\(f'(t_0)\\) = \\(\\frac{ f(t_0- 2\\Delta t) -8f(t_0 - \\Delta t) + 8f(t_0 + \\Delta t) - f(t_0 + 2\\Delta t)) }{12\\Delta t}\\)\n\\(\\mathcal{O}(\\Delta t^4)\\)\n\n\n\n\n\n\nTabela 3.2: Derivadas de Segunda e Terceira Ordem\n\n\n\n\n\n\n\n\nFórmula\nErro\n\n\n\n\nSimétrica de 3 pontos\n\\(f''(t_0)\\) = \\(\\frac{ f(t_0 - \\Delta t) - 2f(t_0) + f(t_0 + \\Delta t) }{\\Delta t^2}\\)\n\\(\\mathcal{O}(\\Delta t^2)\\)\n\n\nSimétrica de 5 pontos\n\\(f''(t_0)\\) = \\(\\frac{ -f(t_0 - 2\\Delta t) + 16f(t_0 - \\Delta t) - 30f(t_0) + 16f(t_0 + \\Delta t) - f(t_0 + 2\\Delta_x)}{12\\Delta t^2}\\)\n\\(\\mathcal{O}(\\Delta t^3)\\)\n\n\nAssimétrica de 4 pontos\n\\(f'''(t_0)\\) = \\(\\pm \\frac{ -f(t_0 \\mp \\Delta t) + 3f(t_0) - 3f(t_0 \\pm \\Delta t) + f(t_0 \\pm 2\\Delta t)) }{\\Delta t^3}\\)\n\\(\\mathcal{O}(\\Delta t)\\)\n\n\nAssimétrica de 5 pontos\n\\(f'''(t_0)\\) = \\(\\frac{ -f(t_0 - 2\\Delta t) + 2f(t_0 - \\Delta t) - 2f(t_0 + \\Delta t) + f(t_0 + 2\\Delta t)) }{2\\Delta t^3}\\)\n\\(\\mathcal{O}(\\Delta t^2)\\)\n\n\n\n\nSobre a temática de erros de truncamento, eu recomendo ao leitor curioso, a palestra do professor John L. Gustafson, discutindo sobre erros numéricos, disponível no YouTube.\nVamos fixar os novos conceitos calculando a derivada de alguma função conhecida, e para aumentar sua cultura, vamos calcular a primeira derivada da Equação Parametrizada de um Coração:\n\\[\n    \\begin{alignat}{4}\n        x(t) &= 16sin^3(t)\\\\\n        y(t) &= 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)\n    \\end{alignat}\n\\tag{3.2}\\]\n\n\n\n\nBaseado na Equação 3.2 :\n\nObtenha a expressão analítica da Primeira Derivada, \\(x'_{exato}\\), e Segunda Derivada \\(x''_{exato}\\).\nImplemente as funções Primeira e Segunda Derivada Simétrica de 3 pontos.\nSorteie um número aleatório para \\(t_0\\).\nCrie um vetor com valores de \\(\\Delta t \\in [10^{-8}, 10^{-1}]\\) em escala logarítmica.\nCalcule \\(|x'(t_0) - x'_{exato}(t_0)|\\) para diferentes valores de \\(\\Delta t\\)\nRepita o item anterior para a Segunda Derivada.\nExiba os resultados em uma Figura de escala log-log. Para melhor interpretação, inverta o eixo X.\n\n\nAgora que você já sabe derivar uma função \\(f(t)\\), usaremos o mesmo raciocínio com vetores. Assim, podemos calcular a derivada da Lei de Planck\n\\[\n        E(\\lambda; T) = \\frac{2hc^2}{\\lambda^5}\\frac{1}{e^{hc/\\lambda kT} - 1} \\times 2.161413 \\cdot 10^{-14}\\pi \\frac{W^2}{m^2 nm}\n\\tag{3.3}\\]\nEssa expressão da Lei de Planck não é apresentada em livros textos de física, ela fornece a Radiância solar, contudo, medições de satélite correspondem a Irradiância. Para mais detalhes, confira a discussão em KatyB [2014] e uma explicação mais esclarecedora em H. Zhu [2019].\n\nNesse exercício, graficaremos a Lei de Planck junto a dados experimentais. Não é necessário entender as origens e fundamentos da Equação 3.3 para realizar o exercício, mas se lhe interessa, sugiro o capítulo 3 do livro James A. Coakley Jr [2014].\n\nComo essa equação é famosa, pesquise os valores das constantes fundamentais, e escreva uma função em Julia que calcule \\(E(\\lambda; T)\\)\nCom \\(T=6000\\), e um vetor \\(\\lambda \\in [200, 2500]\\, \\text{nm}\\), calcule o espectro de irradiância do Sol armazenando os resultados em um vetor chamado \\(E\\_\\lambda\\)\nExiba o espectro que você obteve em uma figura, e normalize o eixo vertical, o comprimento de onda, em nanômetros, ou seja, divida todos os valores do eixo vertical por \\(1 \\text{nm} = 10^{-9}\\text{m}\\). Assim, o eixo vertical poderá ser descrito como ‘\\(\\lambda \\; [\\text{nm}]\\)’.\nClique aqui e baixe os dados que usaremos, esses dados foram obtidos do National Renewable Energy Laboratory Laboratory [2021]. A primeira coluna é o Comprimento de Onda multiplicado por um fator \\(10^9\\) (ou seja, em unidades de \\(nm\\)), e a segunda é a irradiância em \\(W m^{-2} nm^{-1}\\). Sobreponha esses dados experimentais com a figura produzida com os dados teóricos.\n\n\nNosso próximo objetivo é calcular o comprimento de onda no qual a irradiância é máxima, vamos denominar esse valor \\(\\lambda^*\\). A nível computacional é muito fácil, é só usar o comando findmax(). Se os valores do comprimento de onda estão em um vetor \\(\\lambda\\)\nE_max, idx_max = findmax(E_λ)\nλ_star = λ[idx_max]\nSinto informar, mas nós usaremos o caminho das pedras.\n\nVamos achar o máximo com conhecimentos de Cálculo 1: o máximo (ou minimo, ou inflexão) de uma função \\(f(x)\\) existe quando a primeira derivada é nula, \\(f'(x^*) = 0\\).\nA expressão analítica de \\(E'(\\lambda)\\) disponível no Wikipedia é Wikipedia [2021] \\[\n            E'(\\lambda; T) = 2hc^2\\left ( \\frac{hc}{kT\\lambda^7}\\frac{e^{hc/\\lambda kT}}{(e^{hc/\\lambda k T} -1 )^2} - \\frac{1}{\\lambda^6}\\frac{5}{e^{hc/\\lambda k T} -1 }  \\right )\n\\tag{3.4}\\]\n\nImplemente a Primeira Derivada Simétrica de 5 Pontos e aplique sobre os Dados Teóricos que você tem.\n\n\n\n\n\n\n\nAviso\n\n\n\nNão calcule a primeira derivada sobre os dados de satélite, pois as oscilações são grandes o suficientes para atrapalhar nossa análise - e não quero que voê se preocupe com mais problemas.\n\n\n\n\n\n\n\n\nObservação\n\n\n\nVocê esta calculando derivada de vetores, então alguns pontos nas extremidades ficarão sem derivadas, a menos que algum critério especial seja definido. Não faremos nada, simplesmente ignore a derivada nas bordas.\n\n\n\nDiminua a magnitude dos dados com uma normalização do tipo \\(f \\rightarrow f/max(f)\\)\nCrie um vetor com os valores analíticos e também os normalize\nCompare com os valores numéricos com os analíticos em uma figura"
  },
  {
    "objectID": "Projeto3/projeto3.html#raíz",
    "href": "Projeto3/projeto3.html#raíz",
    "title": "3  O Sol",
    "section": "3.3 Raíz",
    "text": "3.3 Raíz"
  },
  {
    "objectID": "Projeto3/projeto3.html#integral",
    "href": "Projeto3/projeto3.html#integral",
    "title": "3  O Sol",
    "section": "3.4 Integral",
    "text": "3.4 Integral\n\n\n\n\nH. Zhu, P.B. 2019. Understanding Radiance (Brightness), Irradiance and Radiant Flux.\n\n\nJames A. Coakley Jr, P.Y. 2014. Atmospheric Radiation: A Primer with Illustrative Solutions. Wiley-VCH.\n\n\nKatyB. 2014. convert units for spectral irradiance.\n\n\nLaboratory, N.R.E. 2021. Solar Spectra.\n\n\nSilva et al, L.G. da. 2019. Termografia de capivaras (Hydrochoerus hydrochaeris) do perímetro urbano de Campo Grande-MS. PUBVET 13, 3, 1–9.\n\n\nWikipedia. 2021. Wien’s displacement law."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "H. Zhu, P.B. 2019. Understanding radiance\n(brightness), irradiance and radiant flux.\n\n\nJames A. Coakley Jr, P.Y. 2014.\nAtmospheric radiation: A primer with illustrative solutions.\nWiley-VCH.\n\n\nKatyB. 2014. Convert units for spectral\nirradiance.\n\n\nLaboratory, N.R.E. 2021. Solar spectra.\n\n\nSilva et al, L.G. da. 2019. Termografia\nde capivaras (hydrochoerus hydrochaeris) do perímetro urbano de campo\ngrande-MS. PUBVET 13, 3, 1–9.\n\n\nStaff, S.B. 2020. Measuring your\nthreshold of hearing for sounds of different pitches.\n\n\nWikipedia. 2021. Wien’s displacement law."
  },
  {
    "objectID": "Projeto2/projeto2.html#atenuação-sonora",
    "href": "Projeto2/projeto2.html#atenuação-sonora",
    "title": "2  Tratamento de Dados",
    "section": "2.2 Atenuação Sonora",
    "text": "2.2 Atenuação Sonora\nExperimentos científicos não feitos apenas para ter resultados em um gráfico, como aconteceu na prática anterior, pois o idealizador do experimento quer obter alguma informação relevante dos dados. Em alguns casos as variáveis relevantes ainda não são claras, e o objetivo do experimento é justamente descobrir quais são as propriedades básicas do sistema, em outros casos já existe um modelo matemático com uma lista de comportamentos esperados, e seu objetivo será obter alguns parâmetros desse modelo.\nComo a modelagem completa do sistema auditivo humano não é tópico de interesse em nosso projeto, trabalharemos com tópico correlato, e muito mais simples, isto é, Atenuação Sonora pela Lei do Inverso do Quadrado da Distância\n\\[\n    I(r) = \\frac{P}{4\\pi r^2},\n\\tag{2.1}\\]\nonde \\(I(r)\\) é intensidade sonora a uma distância \\(r\\) da origem, e \\(P\\) é a potência da fonte. Um experimento que desejasse validar essa equação deveria encontrar 2 números: o primeiro é o termo geométrico \\(4\\pi\\), e o segundo, é o crescimento quadrático, \\(r^2\\). Nessa sessão, não vamos criar um experimento, criaremos os dados e aprenderemos a estimar os parâmetros.\n\nPara nossoas simulações precisamos definir alguns valores para trabalhar com Equação 2.1, e nos basearemos no artigo [Gray 2019], onde o autor calcula quantos decibeis são produzidos por todas os Alexas do mundo tocando a música Despacito ao mesmo tempo1.\n\nCom \\(P=159\\) e \\(r \\in [0.1, 28]\\) (com 30 pontos), faça um scatter de \\(I(r)\\) em escala loglog.\nRefaça a figura anterior, garantindo pontos igualmente espaçados em escala loglog.\nSeria possível criar essa mesma figura com \\(r\\) iniciando em zero?\nSupondo que esses dados foram obtidos de um experimento, você deve obter as constantes para \\(y(x,p) = P/ar^b\\). Já sabemos que \\(a=4\\pi\\) e \\(b=2\\), mas você deve obter isso com o pacote LsqFit.jl. Consulte a documentação do pacote aqui.\nCom os parâmetros que você obteve, aplique eles sobre o domínio \\(r\\) e obtenha um vetor y_fit - e sobreponha com a figura de \\(I(r)\\) anterior para testar a qualidade do seu fit."
  },
  {
    "objectID": "Projeto2/projeto2.html#dados-com-erros",
    "href": "Projeto2/projeto2.html#dados-com-erros",
    "title": "2  Tratamento de Dados",
    "section": "2.3 Dados com erros",
    "text": "2.3 Dados com erros\nSeus resultados experimentais anteriores foram perfeitos ou ideais, já que criamos eles no computador. No mundo real seus dados irão desviar do modelo matemático por inúmeros motivos, desde o equipamento de medição com problemas, até efeitos não-lineares que foram desconsiderados, começarem a serem relevantes. A solução inevitável é estimar o erro dos seus resultados, e existe todo um arcabouço matemático dedicado a isso. No entanto, é um processo chato e trabalhoso. Felizmente, computadores são ótimos para automatizar processos trabalhosos.\n\nVamos recriar o fit do problema anterior, porém adicionaremos erros aleatórios para emular dados reais.\n\nQuando trabalhamos com simulações envolvendo números aleatórios, é uma boa prática cientifica controlar o gerador de números aleatórios, assim, os seus dados podem ser reproduzidos por outras pessoas. Com o pacote Random.jl fixe a seed de números aleatórios com o número 18 - não tem nada de especial com esse número. Ele só foi fixado para você não ficar escolhendo números.\nPara cada valor de \\(I(r)\\), multiplique por um número aleatório com a função rand, e exiba seus novos resultados com scatter plot. Multiplicar por números aleatórios vai garantir que a ordem de grandeza do erro é proporcional ao valor da medição.\nCom o pacote LsqFit.jl calcule novamente os valores dos parâmetros \\(a\\) e \\(b\\). O pacote permite estimar o erro de cada parâmetro com a função stderror(fit) ou o intervalo de confiança com confidence_interval(fit). Exiba curvas de intervalo de confiança, junto da curva y_fit.\n\n\nAté o momento, seus resultados devem estar parecido com a Figura 2.1. Tecnicamente, nós não fizemos errado, usamos equações certas e podemos ainda ajustar a função curve_fit para fixar os limites inferiores/superiores de cada parâmetro, e mesmo assim, eu já lhe garanto que isso não é a solução.\n\n\n\nFigura 2.1: Fit não ideal sobre os dados gerados ao usar valores default da biblioteca LsqFit.jl.\n\n\nNosso erro foi esquecer que trabalhamos com valores em escala logarítmica. O nome do pacote utilizado, LsqFit.jl, significa Least-Squares Fitting, que em essência, calcula o erro quadrático entre sua função modelo com os dados experimentais. Os nossos dados possuem valores que decrescem ordens de magnitude, logo, pontos próximos da origem, possuem erros maiores, e serão as regiões dominantes do ponto de vista do algoritmo.\nA primeira solução é fazer um fit ponderado, no qual você informa ao algoritmo qual a “importância”, o “peso”, a “contribuição” que cada valor \\(I(r)\\) possui, com um vetor w_t. Normalmente você faz esse procedimento quando já conhece alguma informação extra do sistema. No nosso exemplo, isso não é verdade, e o melhor que poderiamos fazer é supor alguns pesos ad hoc, e usar o comando\ncurve_fit(modelo, x_data, y_data, wt, condição_inicial)\nA segunda solução é a correta, vamos linearizar os dados, isto é, nós aplicamos mudanças de variáveis no sistema, de tal forma que ele se comporte como uma equação de primeiro grau. Em problemas com fatores exponenciais, nossa transformação acontece aplicando a função logarítmica:\n\\[\n    \\begin{alignat*}{4}\n    I(r) &= \\frac{P}{4\\pi r^2}\\\\\n    I(r) &= \\frac{1}{r^2}\\cdot\\frac{P}{4\\pi}\\\\\n    log_{10}(I(r)) &= log_{10}\\left (\\frac{1}{r^2} \\right ) + log_{10}\\left (\\frac{P}{4\\pi} \\right )\\\\\n    log_{10}(I(r)) &= log_{10}\\left (r^{-2} \\right ) + log_{10}\\left (\\frac{P}{4\\pi}\\right )\\\\\n    log_{10}(I(r)) &= -2log_{10}(r) + log_{10}\\left (\\frac{P}{4\\pi}\\right )\\\\\n    Y &= -2X + C\n    \\end{alignat*}\n\\tag{2.2}\\]\n\nLinearize seus dados\n\nCalcule o logaritmo de \\(r\\) e \\(I(r)\\)\nRefaça o seu fit com um modelo do tipo \\(y(x,p) = p_1x + p_2\\).\nExiba seus resultados e veja que agora estarão muito melhores."
  },
  {
    "objectID": "Projeto2/projeto2.html#dados-com-mais-erros",
    "href": "Projeto2/projeto2.html#dados-com-mais-erros",
    "title": "2  Tratamento de Dados",
    "section": "2.4 Dados com Mais Erros",
    "text": "2.4 Dados com Mais Erros\nVamos aprimorar o nosso conhecimento do processo de fitting. Nós usamoa a biblioteca LsqFit.jl pela conivência e nos deparamos com uma situação simples onde ela falhou. Felizmente eu lhe disse a origem do problema e sua solução.\nMas e se seu código rodasse dentro de um sistema embarcado?2 Para economizar bateria do equipamento, você gostaria de refazer todas as contas do fit, porém otimizadas com comandos específicos do seu dispositivo. Logo, o que você precisa é conhecer a matemática dos Métodos dos Mínimos Quadrados.\nVamos usar o fitting da função de primeiro grau, pois nós acabamos de usar ela. Suponha uma função modelo do tipo\n\\[\n    y(r) = \\alpha r + \\beta\n\\]\nA distância \\(d_i\\) de cada ponto experimental \\((r_i, I_i)\\) e a curva de fit é:\n\\[\n    d_i = I_i - (\\alpha r_i + \\beta)\n\\]\nO Métodos dos Mínimos Quadrados é autoexplicativo, vamos somar todos os \\(N\\) valores dos erros, \\(d_i\\), ao quadrado. Precisaremos de um nome para essa quantidade, e vou chamar de \\(D\\):\n\\[\n    D = \\sum_{i=1}^N [I_i - (\\alpha r_i + \\beta)]^2\n\\]\nBuscamos o valor mínimo de \\(D\\) variando \\(\\alpha\\) e \\(\\beta\\), ou seja, a primeira derivada parcial deve ser nula:\n\\[\n    \\begin{alignat*}{4}\n    \\frac{\\partial D}{\\partial \\alpha}  &= \\sum_{i=1}^N 2(-r_i)[I_i - (\\alpha r_i + \\beta)]= 0\\\\\n    \\frac{\\partial D}{\\partial \\beta}  &= \\sum_{i=1}^N 2(-1)[I_i - (\\alpha r_i + \\beta)]= 0\n    \\end{alignat*}\n\\]\nAgora reorganizando as expressões, temos uma sistema linear:\n\\[\n    \\begin{alignat*}{4}\n     \\alpha \\sum_{i=1}^N r_i^2 + \\beta \\sum_{i=1}^N r_i  &= \\sum_{i=1}^N r_iI_i\\\\\n    \\alpha \\sum_{i=1}^N r_i + \\beta N  &= \\sum_{i=1}^N I_i\n    \\end{alignat*}\n\\]\nFinalmente, podemos escrever esse sistema em forma matricial:\n\\[\n    \\begin{pmatrix}\n        \\sum_{i=1}^N r_i^2  & \\sum_{i=1}^N r_i  \\\\\n        \\sum_{i=1}^N r_i & N\n    \\end{pmatrix}\n    \\begin{pmatrix}\n        \\alpha \\\\\n        \\beta\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n        \\sum_{i=1}^N r_iI_i \\\\\n        \\sum_{i=1}^N I_i\n    \\end{pmatrix}\n\\tag{2.3}\\]\nSistemas lineares do tipo \\(Ax=b\\) são facilmente resolvidos em Julia com o operador backslash, o barra invertida: \\(x= A\\backslash b\\).\nAté o momento nós obtivemos o valor de \\(\\alpha\\) e \\(\\beta\\), mas ainda faltam as margem de erro. No lugar de aprender os detalhes de estatística de matriz de covariância, vamos focar em outro assunto correlato, mais pertinente a dados experimentais: Cada medição experimental possui um erro associado.\nNão precisamos aprender o cálculo de Propagação de Erros, pois isso é a finalidade de cursos de laboratório. O que faremos é usar um pacote chamado Measurements.jl que faz toda a propagação de erro nativamente em Julia, ou seja, podemos fazer qualquer análise com os nossos dados, e a propagação de erro será automática.\n\nCom os mesmos dados de \\(r\\) e \\(I(r)\\) que você calculo o fit através de linearização. Vamos recalcular o fit usando o sistema de equações que foi apresentado. A diferença, é que você adicionará um erro para cada valor de \\(I(r)\\) e verá a propagação de erros acontecer.\n\nPara cada valor de \\(I(r)\\) adicione um erro experimental3. Nada impede lhe de adicionar erros na medição de \\(r\\), mas a figura final fica confusa, então eu quero que você não faça isso.\nFaça o scatter plot usando o pacote Plots.jl, pois ela é integrada com o pacote , e seus gráficos já terão barras de erros.\nCrie novos vetores \\((r\\_log, I\\_log)\\), com os valores de \\((r, I(r))\\) em escala logarítmica.\nResolva o sistema linear da Equação 2.3 com os seus dados de \\((r\\_log, I\\_log)\\).\nPara extrair o Valor do fit use Measurements.value, e para as incertezas, use Measurements.uncertainty. Com esses comandos, você consegue calcular a margem de erro, e finalmente pode exibir a última figura com todos os resultados.\n\n\nAo final desse projeto, sua figura estará próxima da Figura 2.2.\n\n\n\nFigura 2.2: Fit usando Método dos Mínimos Quadrados de dados linearizados, e com propagação de erros.\n\n\n\n\n\n\nGray, A. 2019. How Loud Would It Be If Every Alexa In The World Played «Despacito» At The Same Time? Journal of Interdisciplinary Science Topics 8.\n\n\nStaff, S.B. 2020. Measuring Your Threshold of Hearing for Sounds of Different Pitches."
  }
]